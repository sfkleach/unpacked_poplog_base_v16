% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%     Extracts from the book "Natural Language Processing in POP-11"    %
%                      published by Addison Wesley                      %
%        Copyright (c) 1989, Gerald Gazdar & Christopher Mellish.       %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

Question answering

    Old notation                New notation

    <predicate> = p                   [p a0 a1]
    <arg0> = a0
    <arg1> = a1

    <connective> = c                  [c p1 p2]
    <prop1> = p1
    <prop2> = p2

    <quantifier> = q                  [q v r b]
    <variable> = v
    <restriction> = r
    <body> = b

For example:

    Old notation                New notation

    <quantifier> = all                [all _x [airline _x] [employer _x]]
    <restriction predicate> = airline
    <restriction arg0> = <variable>
    <body predicate> = employer
    <body arg0> = <variable>

    <connective> = and                [and [airline Delta] [hotel_chain Hilton]]
    <prop1 predicate> = airline
    <prop1 arg0> = Delta
    <prop2 predicate> = hotel_chain
    <prop2 arg0> = Hilton

In translating from the old notation to the new, we replace all values
for the VARIABLE feature by variable symbols in such a way that two
such symbols are the same, exactly when the two values share in the
DAG.  As before, we indicate variable symbols by words beginning with
'_'.  Where a database predicate is involved, the number of objects in
the list will, of course, depend on the predicate concerned.  For
instance:

    [airline _x]

might represent the proposition that _x is an airline and:

    [took_over _x _y]

might represent the proposition that '_x' took over '_y'.  Here are
some examples of queries in the POP-11 notation, together with natural
language questions that they might correspond to.

    [all _x
        [airline _x]
        [us_based _x]]
    "every airline is US based"

    [all _x
        [airline _x]
        [printout _x]]
    "what airlines are there?"

    [all _x
       [and [airline _x]
            [exists _y [hotel_chain _y]
                       [took_over _x _y]]]
       [printout _x]]
    "what airlines took over a hotel chain?"

    [all _x
        [and [hotel_chain _x]
             [exists _y [owns _x _y]]]
        [printout _x]]
    "which hotel chains have subsidiaries?"

Evaluating DBQ formulae

Our algorithm for evaluating DBQ formulae will not actually provide
truth values directly for a formula, but will produce a set of
substitutions reflecting possible values for variables appearing in
the formula that yield true propositions.  It is simplest to see this
for formulae of the first type (involving simple predicates).  Imagine
that we have a database about car parts which includes information
about which firms supply which parts.  We will assume that a relation
supplies is represented in the database by a long list of entries
specifying exhaustively who supplies what, as follows:

    Who            What

    smith_corp     radiators
    jones_inc      spark_plugs
    morgan_bros    radiators
    jones_inc      batteries
    smith_corp     tyres
    morgan_bros    pumps

Questions about this relation can be phrased in DBQ by using the
predicate supplies.  We will use the first (ARG0) argument position
associated with supplies to indicate the supplying firm and the second
(ARG1) position to indicate the type of part.  Then, the following are
possible DBQ formulae involving this relation:

    [supplies _x radiators]
    [supplies _x _y]

The result of evaluating the first of these formulae will be the set
of possible values for _x which would result in the formula matching
something in the database.  So what we get is:

    [[[_x smith_corp]]
     [[_x morgan_bros]]]

The result of evaluating the second of the formulae will be the set of
pairs of values for _x and _y that result in the formula matching
something in the database. In this case, the result corresponds to the
whole relation represented by:

    [[[_x smith_corp] [_y radiators]]
     [[_x morgan_bros] [_y spark_plugs]]
      ...                               ]

In general, a DBQ formula involving a predicate and associated
arguments will be assumed to correspond to a primitive relation, each
true case of which is explicitly listed in the database.  The
evaluation of such formulae is dealt with by the database and returns
the set of possible variable bindings that allow the formula to match
a true fact recorded there.

Let us now consider the more complex kinds of DBQ formulae.  In
general, there needs to be a special way of evaluating each kind of
conjunction and each kind of quantifier.  Consider the and
conjunction.  We want the truth value of an and proposition to be true
if and only if each of the two sub propositions is true.  A value of a
variable will satisfy such a complex proposition only if it satisfies
both of the subpropositions.  So, here is a way of generating the
possible substitutions for a conjunction:

    To evaluate [and P1 P2]:
       Let the set of answers computed so far be empty
       Evaluate P1, to give the set of substitutions S1
       For each element s1 of S1:
          Apply s1 to the proposition P2, yielding P2'
          Evaluate P2', giving the set of substitutions S2
          For each element s2 of S2:
             Combine s1 with s2, and add the result to the
             Set of answers computed so far
       Return the set of answers computed so far

We have made use here of the operations of applying and combining
substitutions.  We have already come across these operations via the
POP-11 procedures apply_subst and compose_subst.  Consider the
evaluation of the following DBQ formula:

    [and [supplies _x radiators] [supplies _x _y]]

Evaluating the first part ([supplies _x radiators]) of the and
proposition against our database results in the first of the set of
substitutions given above:

    S1:
    [[[_x smith_corp]]
     [[_x morgan_bros]]]

Each of these two substitutions is dealt with separately.  First of
all, the substitution '[[_x smith_corp]]' is considered.  The second
part of the and proposition is rewritten so that all occurrences of _x
are replaced by smith_corp - this is applying the substitution to the
formula.  As a result, we now have the following formula:

    [supplies smith_corp _y]

Evaluating this gives rise to the second set of substitutions:

    S2:
    [[[_y radiators]]
     [[_y tyres]]]

To get possible answers, we combine the elements of S2 one by one with
the element chosen from S1.  This just means getting the pairs of
substitutions to pool their information.  So, we get the following two
answers:

    [[[_x smith_corp] [_y radiators]]
     [[_x smith_corp] [_y tyres]]]

To complete the set of answers, we need to consider the second
substitution in S1.  Applying this to the second part of the and
proposition gives:

    [supplies morgan_bros _y]

and evaluating this gives:

    S2:
    [[[_y radiators]]
     [[_y pumps]]]

Once more we combine these substitutions with the one selected from
S1, this time generating the two answers:

    [[[_x morgan_bros] [_y radiators]]
     [[_x morgan_bros] [_y pumps]]]

Now that we have dealt with all the elements of S1, we can enumerate
the set of substitutions that result from evaluating the whole
formula:

    [[[_x smith_corp] [_y radiators]]
     [[_x smith_corp] [_y tyres]]
     [[_x morgan_bros] [_y radiators]]
     [[_x morgan_bros] [_y pumps]]]

Notice that the algorithm for evaluating an and proposition invokes
the evaluation algorithm recursively on the parts of the formula.  The
algorithm will act similarly for other conjunctions and quantifiers.
The recursion will bottom out every time because each recursive call
is operating on a smaller piece of formula than the one that invoked
it.  So, eventually, the recursive calls will cause the evaluation of
simple predicate formulae, which can be done by the database without
any further recursive calls.

In evaluating a DBQ formula, we will only be interested in
substitutions for variables that appear outside the formula.  For
instance, in the and example it was important to remember the possible
values of X satisfying the first subformula, in order to use them in
evaluating the second.  Now, the assumption will be made here that a
quantified formula will never contain variables that are used outside
(that is, free variables).  So, this means that when a quantified
formula is evaluated we need only ever produce one of two possible
answers:

    []
    [^empty_subst]

The first of these answers says that there are no substitutions that
will make this formula true, whereas the second says that there is a
substitution that will make the formula true, but it is empty because
the formula has no free variables.  Here is the part of the evaluation
algorithm dealing with the all and exists quantifiers:

    To evaluate [all V R B]:
       Evaluate R, to give the set of substitutions S1
       If there are none, simply return [^empty_subst]
       Otherwise, for each element s1 of S1:
          apply s1 to the proposition B, yielding B'
          if B' evaluates to give at least one substitution,
             continue going through the elements of S1
          otherwise immediately return []
       If you get successfully through all the elements of S1,
          return [^empty_subst]

    To evaluate [exists V R B]:
       Evaluate R, to give the set of substitutions S1
       If there are none, simply return []
       Otherwise, for each element s1 of S1:
          apply s1 to the proposition B, yielding B'
          if B' evaluates to give at least one substitution,
             immediately return [^empty_subst]
          otherwise continue going through the elements of S1
       If you get through all the elements of S1 without any success,
          return []

Intuitively, the all algorithm goes through all the values of the
variable satisfying the restriction and checks that they satisfy the
body.  Only if they all satisfy can it return [^empty_subst] - that
is, true.  On the other hand, the exists algorithm is content to
return [^empty-subst] if there exists any value of the variable that
makes both the restriction and the body true.  Consider, for example,
the evaluation of:

    [all _x [supplies _x radiators] [supplies _x tyres]]

given our example database.  The evaluation of the restriction part
provides the following set of substitutions:

    S1:
    [[[_x smith_corp]]
     [[_x morgan_bros]]]

Taking the first of these and applying it to the body, we get:

    [supplies smith_corp tyres]

which evaluates to [^empty-subst].  So, we continue with the second
substitution in S1.  This time, the second formula to be evaluated is:

    [supplies morgan_bros tyres]

which yields [].  Because of this, the evaluation of the whole formula
returns [].  The evaluation has indicated that 'everyone who supplies
radiators supplies tyres' is false, because Morgan Bros supplies
radiators but not tyres.

Notice that the above strategy of evaluating the restriction R in
order to substitute values into the body B will only work if the
evaluation of the restriction actually produces substitutions for the
variable.  Not every DBQ formula will, however, produce substitutions
for all the variables in it when it is evaluated.  For instance,
evaluating an 'all' formula, whether or not it is successful, never
yields any interesting substitutions.  So, in order for query
evaluation as we have sketched it to work, we must require that a
restriction formula be one of the following:

(1)  a simple proposition mentioning the variable (e.g. [owns _x _y]
     mentions _x and _y) or

(2)  a conjunction with such a proposition as its first conjunct.

If a DBQ formula is coming from the analysis of an English sentence,
this restriction is rarely a problem, because most NPs provide via a
noun a simple proposition about the referent which will appear in the
restriction part of the relevant DBQ formula.  For instance, 'every
airline' gives rise to a DBQ formula where the restriction is the
simple proposition [airline _x], where _x is the variable quantified
over in the formula.

We have now sketched out the main components of an evaluation
algorithm for DBQ formulae.  Put together, these form a recursive
algorithm for evaluating a formula by recursively evaluating its
components in particular ways.  The algorithm returns a set of
substitutions, rather than a truth value, but for a formula with no
free variables the possible results, [^empty_subst] and [], do
indicate true and false, respectively.  The algorithm as sketched can
also be extended to handle other conjunctions, logical operators and
quantifiers, such as or, not, most.

When a DBQ formula is treated as a database query, it is assumed that
the person posing the query is interested in whether the proposition
expressed is true or not.  In general, they may be interested in
knowing for what objects a given proposition is true, as well as
knowing whether there are such objects.  So, DBQ allows the
specification of certain extra actions that are to be carried out
during query evaluation.  Such actions are treated as propositions
that are always true, but which cause side effects to occur when their
truth is verified.  The only action we will actually use is that of
printing out the value of a variable (that makes some proposition
true).  This will give rise to a DBQ form like

    [printout _x]

We really need to introduce a clause into the algorithm for such
things, as follows:

    To evaluate [printout X]:
                Print out X
                Return [^empty_subst]

Of course, to introduce such actions sensibly into our DBQ formulae,
we need to know when they will be encountered in the evaluation
process.  Thus, for instance, we want a printout action only to be
encountered after a particular value has been put in the place of the
relevant variable.

The algorithm for query evaluation is easily expressed purely in POP-
11.  Lib dbq provides a procedure query which takes a query,
represented as a POP-11 list structure, and returns the list of
substitutions that make it true.  We have already represented
substitutions in POP-11 and lib dbq uses lib subst to manipulate
these.  The operations of applying and combining substitutions are
thus provided by the procedures apply_subst, or lookup_subst if the
argument is a variable, and compose_substs, respectively.  Sets of
substitutions are represented by lists, with [] representing the empty
set, which is false in this context.  Here is the part of the program
that deals with all constructions:

       if formula matches [all ?x ?p1 ?p2] then
          for subst in query(p1) do
             lookup_subst(x, subst) -> xval;
             if xval = x then
                mishap('ALL condition does not bind variable', [^x ^p1])
             endif;
             add_subst(x, xval, empty_subst) -> xsubst;
             if query(apply_subst(xsubst,p2)) = [] then
                return([])
             endif
          endfor;
          [^empty_subst]

Notice how the code checks that the all condition always finds a value
for the variable.  This should always happen with formulae arising
from natural language queries.  Here is how the and case looks in
POP-11:

       elseif formula matches [and ?p1 ?p2] then
          [%
             for subst1 in query(p1) do
                for subst2 in query(apply_subst(subst1, p2))
                   do compose_substs(subst1, subst2)
                endfor
             endfor
          %]

When the recursion reaches a simple proposition, the procedure
retrieve_all is called.  Retrieve_all takes a simple proposition and
returns a list of substitutions, corresponding to all ways the
proposition can be found in the database (represented, of course, by
the POP-11 database).  The procedure replaces all variables in the                     
proposition by occurrences of '=' and uses the standard foreach to
find the instances that appear in the database.  These are then
compared with the original proposition to yield substitutions for the
variables appearing in it.  For instance, if the query is:

    [supplies _x radiators]

and the database is:

    [[supplies smith_corp  radiators]
     [supplies jones_inc   spark_plugs]
     [supplies morgan_bros radiators]
     [supplies jones_inc   batteries]
     [supplies smith_corp  tyres]
     [supplies morgan_bros pumps]
    ] -> database;

then the query is translated to:

    [supplies = radiators]

and foreach is used to find each way this can be POP-11 matched to an
element of the database.  This yields in turn the following values for
the special POP-11 variable it:

    [supplies smith_corp  radiators]
    [supplies morgan_bros radiators]

Each of these is compared to the original [supplies _x radiators],
yielding a substitution for '_x' which is returned.  The procedure
performing this comparison is called termunify, which of course
implements term unification, as discussed in Chapter 7.

Implementing backwards and forwards inference

Lib bckinfer is a program for doing backwards inference using a POP-11
adaptation of our rule notation.  We will assume that a rule is
represented by a list whose first element is the conclusion and whose
remaining elements are the conditions.  Each such element will be a
simple proposition represented in the same way as in the DBQ language.                     
Thus, for instance, here is the POP-11 version of one of the rules
about credit cards:

    [[accepts _x _y] [credit_card _x] [registered _x _y]]

A rule that has no conditions will then simply be a list with one
element, for instance:

    [[credit_card visa]]

We will assume that the global variable infrules will hold the list of
inference rules that are going to be used.  An example of such a list
is given in lib airdb2.

The procedure back_infer is responsible for backwards inference.  It
is provided with a single inference goal, a proposition that may
contain variables, and it returns the list of substitutions that
correspond to the inferable instances of the goal.  For instance:

    [[[employs velsoft cathy_smith]]
     [[employs mobtek john_martin]]
     [[employs velsoft sharon_redding]]
     [[employs singco peter_butcher]]] -> infrules;

    back_infer([employs velsoft _x]) =>
    ** [[[_x sharon_redding]] [[_x cathy_smith]]]

The core of back_infer is the following loop, which deals with each
inference rule R whose conclusion unifies with the goal goal, whose
predicate is predicate and whose length, as a list, is len):

       [] -> substs;
       ...
          for rule in infrules do
              if hd(hd(rule)) = predicate and
                 length(hd(rule)) = len then
                 rename(rule) --> [?head ??body1];
                 termunify(goal, head) -> subst1;
                 if subst1 then
                    apply_subst(subst1, body1) -> body2;
                    for subst2 in back_infer_all(body2)
                        do compose_substs(subst1, subst2) :: substs -> substs
                    endfor
                 endif
              endif
          endfor;
          substs

Each applicable rule yields a substitution, subst1, which is applied
to the body of the rule (the list of conditions).  This modified rule
body is then sent to back_infer_all, which returns the set of
additional substitutions that have to be applied to make true
instances of the conditions.  The results of back_inferare then the                     
substitutions that result from composing these with the initial
substitution generated by the unification.  For instance, in the
following the binding for _x (velsoft) comes from the first
unification, and the binding for _y comes from the satisfaction of the
subgoals [[good_worker _x]]:

     [[[employs velsoft _x] [good_worker _x]]
      [[good_worker cathy_smith]]
      [[good_worker sharon_redding]]] -> infrules;

    trace back_infer back_infer_all;

    back_infer([employs _x _y]) =>
    >back_infer [employs _x _y]
    !>back_infer_all [[good_worker _y]]
    !<back_infer_all [[[_y sharon_redding]] [[_y cathy_smith]]]
    <back_infer [[[_13 _y] [_x velsoft] [_y cathy_smith]]
                 [[_13 _y] [_x velsoft] [_y sharon_redding]]]
    ** [[[_13 _y] [_x velsoft] [_y cathy_smith]]
        [[_13 _y] [_x velsoft] [_y sharon_redding]]]

Note that the variable that prints out as _13 is the _x in the use of
the first inference rule (which is unified with _y in the goal).  The
inference rule has to be renamed so that the _x in the use of the rule
can be distinguished from the _x in the original goal.

Back_infer_all simply takes a list of goals and calls back_infer on
them.  For each solution of the first goal, it applies that
substitution to the rest and then works on the rest.  The results from
back_infer_all come from composing the substitutions that are obtained
from the individual goals.

    define back_infer_all(goals1);
       vars goal goals2 subst1 subst2;
       if goals1 matches [?goal ??goals2] then
          [%
             for subst1 in back_infer(goal) do
                 for subst2 in back_infer_all(apply_subst(subst1, goals2)) do
                     compose_substs(subst1, subst2)
                 endfor
             endfor
          %]
       elseif goals1 = [] then
          [^empty_subst]
       else
          mishap('Illegal format for goals', [^goals1])
       endif
    enddefine;

Lib forinfer implements a simple forwards inference system, with the
main procedure for_infer.  For_infer takes a simple proposition, which
is assumed to contain no variables, and adds it to the database of                     
inference rules.  If the presence of this new fact makes any inference
rules apply in new ways, then the conclusions of those rules are also
added to the database.  This may cause more rules to run, and so on.
The procedure keeps track of the assertions it still has to add in a
list toadd, which is much like the agenda in a chart parser:

    define for_infer(assertion);
       vars toadd a new;
       if find(assertion) = [] then
          [^assertion] -> toadd;
       else
          [] -> toadd
       endif;
       until toadd = [] do
          toadd --> [?a ??toadd];
          [adding ^a] =>
          for new in consequences(a) do
             unless find(new) /= [] or member(new, toadd) or new = a then
                [^new ^^toadd] -> toadd
             endunless
          endfor;
          [[^a] ^^infrules] -> infrules;
       enduntil
    enddefine;

The core of for_infer is the procedure consequences, which returns all
the immediate logical consequences of a new fact assertion.  Each new
assertion in the list returned by consequences will in general be
placed on the toadd list, but this only happens if the assertion is
not already in the database and if it is not already a member of toadd
or (by some chance) the original assertion.  The first of these is
checked by the procedure find, which is just like back_infer, except
that it only looks at facts (not rules) in the database.  Here is the
definition of CONSEQUENCES:

    define consequences(assertion);
       vars rule pattern predicate len subst1 subst2 toadd RHS patterns2;
       [%
          hd(assertion) -> predicate;
          length(assertion) -> len;
          for rule in infrules do
             tl(rule) -> RHS;
             for pattern in RHS do
                if hd(pattern) = predicate and length(pattern) = len then
                   termunify(assertion, pattern) -> subst1;
                   if subst1 then
                      apply_subst(subst1, delete(pattern, RHS)) -> patterns2;
                      for subst2 in find_all(patterns2) do
                          apply_subst(compose_substs(subst1, subst2), hd(rule))
                      endfor
                    endif
                 endif
             endfor
          endfor;
       %]
    enddefine;

The procedure looks through all inference rules and, for each one,
tries to unify the new fact with each condition (pattern in RHS) in
turn.  If it manages to do this, it tries to find instances of all the
other conditions in the database.  The procedure find_all is just like
back_infer_all, except that it only looks for facts, it does not use
any inference rules that themselves have conditions.  For each way
that these other conditions can be satisfied, there is an appropriate
substitution and this (subst2), together with the substitution
obtained by unifying with the original condition (subst1), determines
the instance of the rule conclusion that has now been inferred to be
true.

A simple semantic network in POP-11

Implementing a simple semantic network in POP-11 is straightforward.
In the POP-11 database, we put entries of the form:

    [attr ?entity ?attribute ?value]
    [isa ?entity1 ?entity2]

The first kind of entry is so that we can stipulate what value
particular attributes have for particular entities; we will make no
distinction between individuals and classes in our system - they both
count as entities.  Where an attribute is a property that an entity
may or may not have, we just use the values yes and no accordingly.
The second kind of entry specifies that the first entity comes
directly below the second in the isa-hierarchy.  So, here is an
example semantic network representing information about the membership
of an organization:

          [[attr club_member sex male]
           [attr club_member over_50 yes]
           [attr club_member citizenship US]

         [isa associate club_member]
           [attr associate associate_member yes]
           [attr associate citizenship non_US]

         [isa life_member club_member]
           [attr life_member life_member yes]
           [attr life_member over_50 no]

         [isa kim associate]
           [attr kim over_50 no]

         [isa jean associate]
           [attr jean sex female]
           [attr jean citizenship US]

         [isa mayumi life_member]
           [attr mayumi sex female]
           [attr mayumi over_50 yes]
           [attr mayumi citizenship non_US]

         [isa beryl life_member]
           [attr beryl sex female]] -> database;

We can now define a procedure get_attr to retrieve the correct value
of a given attribute for a given entity, using inherited information,
if necessary.  This procedure, together with the example network,
appears in lib inherits.

    define get_attr(entity1, attribute);
       vars entity2 value;
       if present([attr ^entity1 ^attribute ?value]) then
          value
       else
          foreach [isa ^entity1 ?entity2] do
             get_attr(entity2, attribute) -> value;
             if value then return(value) endif
          endforeach;                     
          false
       endif
    enddefine;

Notice that because of the order of the if clauses in this procedure,
an attribute value specified locally for an entity will always be
chosen over values obtained through inheritance.  So, inherited
information is interpreted as default information that can be
explicitly overridden locally.  Get_attr returns false if there is no
value specified for the attribute, and this fact is used to determine,
for each entity E1 immediately above the original entity entity in the
hierarchy, whether a value can be obtained by inheritance from that
entity.  Here is an exhaustive listing of the conclusions about Kim,
Jean, Mayumi and Beryl that can be drawn from this new example
network, under the intended default inheritance interpretation:

    Kim is an associate member.
    The sex of Kim is male.
    Kim is not over 50.
    The citizenship of Kim is non-US.

    Jean is over 50.
    Jean is an associate member.
    The sex of Jean is female.
    The citizenship of Jean is US.

    Mayumi is over 50.
    Mayumi is a life member.
    The citizenship of mayumi is non-US.
    The sex of Mayumi is female.

    Beryl is a life member.
    The citizenship of Beryl is US.
    The sex of Beryl is female.
    Beryl is not over 50.

Notice that for the results of the program to make sense, the semantic
network must be set up so that at most one value can be found for each
entity and attribute.  For this we require that if an entity has an
attribute specified by more than one ancestor, then one of those
ancestors is itself an ancestor of the other.  Moreover, we require
that no entity is associated locally with more than one value for a
given attribute.
